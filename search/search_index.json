{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Enowars","text":"<p>Enowars is a Framework for running A/D CTF events.</p>"},{"location":"#overview","title":"Overview","text":"<p>It's complex:</p> <p><pre><code>graph TB\n    EnoLauncher\n    EnoEngine\n    EnoFlagSink\n    EnoELK\n    database[(Database)]\n    router{Router}\n    checker1[[Checker 1..N]]\n\n\n    router --&gt; team\n    router --&gt; EnoFlagSink\n    EnoEngine --&gt;|send logs| EnoELK\n    EnoEngine --&gt;|send scoreboard data| EnoScoreboard\n    EnoEngine --&gt;|plan checks| database\n    database --&gt;|get reports| EnoEngine\n    EnoLauncher --&gt;|run| checker1\n    EnoLauncher --&gt;|report| database\n    EnoFlagSink --&gt; database\n    checker1 --&gt; router\n    checker1 --&gt;|send logs| EnoELK\n\n\n\n    subgraph teams[Team Networks]\n        team[Team 1..N]\n    end\n</code></pre> Now that you've seen this beautiful \ud83d\ude01 chart everything should be clear. For everyone else see below.</p>"},{"location":"#infrastructure","title":"Infrastructure","text":"<p>Click here to get up and running with the underlying OS and Network stuff.</p> <p>If you are the software guy/girl have a look at the engine.</p>"},{"location":"#services-and-checkers","title":"Services and Checkers","text":"<p>If you want to program your own service and submit it to us have a look at our Create a service Guide.</p> <p>Previous Services can be found on our Github Page</p>"},{"location":"#miscellaneous","title":"Miscellaneous","text":"<p>To support everything we have an army of rogue shell and python scripts, as well as Libraries for testing. </p> <p>EnoChecker</p> <p>TBD: Specification</p>"},{"location":"rules/","title":"Rules","text":"<p>Flag format: <code>ENO[A-Za-z0-9+\\/=]{48}</code></p> <p>The game will start on the specified time (UTC time!). You must register at least X hours before the specified time.</p> <p>You must check in between X hours and X hours before the start time.</p> <p>You must start your vulnbox once the game starts. A round lasts 60 seconds, flags are valid for several rounds.</p> <p>Flag submission: <code>netcat flags.bambi.ovh 1337</code></p>"},{"location":"rules/#scoring","title":"Scoring","text":"<p>We are currently using the scoring formula by Faust CTFhttps://2019.faustctf.net/information/rules/.</p>"},{"location":"rules/#social-conduct","title":"Social Conduct","text":"<ol> <li> <p>The vulnerable services of your opponents are your only valid targets. Do not engage anything else!</p> </li> <li> <p>Do not attempt to exhaust resources on your opponents' vulnboxes, for example by sending excessive amounts of requests or exploiting vulnerabilities leading to a denial of service.</p> </li> </ol> <p>Vulnboxes and VPN servers are provided by us, you don't have to provide or take care of anything.</p>"},{"location":"infrastructure/engine/","title":"Engine Installation","text":""},{"location":"infrastructure/engine/#overview","title":"Overview","text":"<p>The Engine is the core Software glueing everything togehter, it consists of: </p> <ul> <li>EnoEngine</li> <li>EnoLauncher</li> <li>EnoFlagSink</li> <li>EnoELK<ul> <li>Elasticsearch (search engine, noSQL)</li> <li>Logstash (ingest and transform data)</li> <li>Kibana (webfrontend)</li> </ul> </li> <li>EnoMoloch</li> <li>ScoreBoard</li> </ul>"},{"location":"infrastructure/engine/#setup","title":"Setup","text":"<p>How to setup the engine for a CTF? </p>"},{"location":"infrastructure/infrastructure/","title":"Infrastructure Setup","text":""},{"location":"infrastructure/infrastructure/#getting-started","title":"Getting started","text":"<p>Everything is inside here: https://github.com/enowars/bambictf</p>"},{"location":"infrastructure/round/","title":"Inner Workings","text":"<p>In order to store flags to capture and check whether a teams service is still running nominally the Engine dispatches several requests in each round.</p>"},{"location":"infrastructure/round/#request-types","title":"Request Types","text":"Request Purpose <code>putflag</code> Inserts the flag into the service <code>getflag</code> Retrieves the flag from the service <code>havoc</code> Checks the service functionality <code>putnoise</code> Insert other (public) data into the service <code>getnoise</code> Check other (public) data"},{"location":"infrastructure/round/#basic-requests","title":"Basic requests","text":"<pre><code>sequenceDiagram\n    Gameserver-&gt;&gt;+Checker: putflag\n    Checker-&gt;&gt;+Service: store flag\n    Gameserver-&gt;&gt;+Checker: getflag\n    Checker-&gt;&gt;+Service: retrieve flag\n    Service-&gt;&gt;+Checker: retrieve flag\n\n</code></pre>"},{"location":"infrastructure/round/#timing","title":"Timing","text":"<p>One round generally lasts 60 seconds. It is divided into 4 quarters, which each last 15 seconds. The checker tasks are called in the depicted way:</p> <p>TODO: Are those scheduled right (the slides differ)?</p> <pre><code>gantt\n    title Timing\n    dateFormat  mm-ss\n    axisFormat  %M-%S\n    section Round 1\n\n    putflag (Round 1 flags) :r1p1, 00-00, 15s\n    getflag (old flags)     :r0g2, 00-00, 15s\n\n    getflag (old flags)     :r0g2, 00-30, 15s\n    havoc                   :r1h1, 00-30, 15s\n    putnoise                :r1pn1, 00-30, 15s\n\n    getflag (Round 1 flags) :r1g1, 00-45, 15s\n    getflag (old flags)     :r0g3, 00-45, 15s\n\n    section Round 2\n\n    putflag         :a1, 01-00, 15s\n\n</code></pre>"},{"location":"infrastructure/test-setup/","title":"Test Setup","text":"<p>If you want a cheap way to test all of your service and infrastructure on one VM, that's you guide. </p>"},{"location":"infrastructure/test-setup/#installation","title":"Installation","text":""},{"location":"infrastructure/test-setup/#managing-the-server","title":"Managing the server","text":"<pre><code># Start Engine Services \nbash tmux.sh\n# Monitor EnoEngine \ntmux a -t enoengine_session\n</code></pre>"},{"location":"infrastructure/testing/","title":"Test run the infrastructure","text":"<p>https://github.com/enowars/enochecker_test</p>"},{"location":"play/general/","title":"Playing a CTF","text":""},{"location":"play/general/#general","title":"General","text":"<p>A typical attack/defense CTF consists of three components.</p>"},{"location":"play/general/#the-gameserver","title":"The Gameserver","text":"<p>It is provided by the organizers and runs throughout the competition, starting when the network is opened. It periodically stores flags on your Vulnbox using functionality in the provided services. It then later retrieves these flags, again using existing functionality. The Gameserver does not run exploits! It simply uses the service as intended. Now, why can't the other teams then simply do what the Gameserver does? The Gameserver has more information. Every service is either designed to allow the Gameserver to store a specific token for each flag or generates one and returns it to the Gameserver. The Gameserver uses this token to check periodically that the flag is still there. Whether or not it gets the stored flag using that token, determines your SLA (Service Level Agreement). You mustn't remove or break any legitimate functionality. Some services can have a vulnerability that directly leaks the flag, which will let you retrieve the flag easily. For others, it will require more effort.</p>"},{"location":"play/general/#your-vulnbox","title":"Your Vulnbox","text":"<p>The Vulnbox is your running instance of the virtual machine image given to you by the organizers. It contains and runs all the services of the competition and should be reachable at all times. The Gameserver stores its flags here and uses the communication with this machine to decide if your services are working as intended or not. This machine is accessible to everyone on the network, and is the target for all the exploits from other teams. Protecting the flags on this machine is what determines your defense points! You normally have one hour from getting access to your Vulnbox until the network between teams is opened and everyone can attack each other. Use this time to get the VM running, then start analyzing what's running on it. It has happened that services with vulnerabilities that are easy to find have been exploited as soon as the actual competition starts. For the Bambi CTF, we will be providing hosted vulnboxes which are accessible via SSH.</p>"},{"location":"play/general/#the-other-teams","title":"The other teams","text":"<p>All the other registered teams are connected to the same VPN as you. Their Vulnboxes have known IP addresses, all other machines are off-limits! The other teams will run exploits from their own machines, but the VPN infrastructure will use NAT to obfuscate whether a packet came from the Gameserver or another team. Successfully stealing and submitting flags from the Vulnbox of other teams determines your attack score! If you have played jeopardy CTFs before, you already know flag submission. In this game however, you'll have to run you exploits periodically, as new flags get stored by the Gameserver every few minutes. So you probably want to script exploits and submit Flags automatically and you don't spend all your time manually exploiting everyone.</p> <p>Adapted from FAUST CTF</p>"},{"location":"play/general/#network","title":"Network","text":"Summary <ul> <li>Game Network: <code>10.0.0.0/16</code></li> <li>Team Vulnbox: <code>10.0.0.{TeamId}/32</code></li> <li>Game Router: <code>10.0.1.1</code></li> <li>Flag Submission: <code>10.0.13.37:1337</code></li> </ul> <pre><code>graph LR\n    gamerouter[Game Router] --&gt; flagsubmission[Flag Submission]\n\n    subgraph team1[Team 1]\n    vuln1[Vulnbox Team 1] --&gt; gamerouter\n    player1[Player 1]--&gt; vpn1[VPN]\n    vpn1 --&gt; vuln1\n    end\n\n    subgraph team2[Team 2]\n    vuln2[Vulnbox Team 2] --&gt; gamerouter\n    player2[Player 2]--&gt; vpn2[VPN]\n    vpn2 --&gt; vuln2\n    end\n\n\n    subgraph teamN[Team N]\n        vulnN[Vulnbox Team N] --&gt; gamerouter\n        playerN[Player N]--&gt; vpnN[VPN]\n        vpnN --&gt; vulnN\n    end\n\n\n</code></pre> <p>To access your vulnbox, you must first start it. This will only be possible once the competition has started. Note that you must check in before the competition starts, otherwise you will not be able to start your vulnbox.</p> <p>Please refer to the rules page for more information.</p> <p>After the vulnbox is started, you will be shown your public vulnbox IP address and the root password which you can use to login. You will also be able to download an OpenVPN configuration file only after the vulnbox is started. See the section below for more details.</p> <p>During the first hour of the CTF, the game network will be closed. This means you will not be able to reach the vulnboxes of other teams through the competition network. To check that your vulnbox and OpenVPN client is working as intended, you can try pinging <code>10.0.1.1</code>, which is the game router and should also be reachable even while the game network is closed.</p> <p>The router performs SNAT on all game traffic, so all incoming traffic appears to be coming from <code>10.0.1.1</code>, regardless of whether it is coming from the game engine or other teams.</p> <p>The <code>10.0.240.0/24</code> subnet for the team VPN is identical for all teams. These networks are completely separated from each other and you will not be able to access the devices in the VPN of other teams.</p> <p>You can get a newline-separated list of all (confirmed) vulnbox addresses at the game portal</p>"},{"location":"play/general/#openvpn-access-for-players","title":"OpenVPN Access for Players","text":"<p>We will provide an OpenVPN server through which you can access your vulnbox and the vulnboxes of the other teams (the latter only once the network has been opened). To get seamless access to the game network, install the OpenVPN client for your operating system, and download the client configuration file that will be provided in the enowars portal. The config file will only be available once your have started your vulnbox. Note that the vulnbox serves as OpenVPN server for your team, so you will only be able to access the game network while your own vulnbox is running. The OpenVPN config file can be shared by all members of your team and allows multiple connections at once. Please consult a search engine of your choice or the OpenVPN documentation for help getting started with OpenVPN.</p>"},{"location":"play/service-status/","title":"Playing a CTF","text":""},{"location":"play/service-status/#service-status","title":"Service Status","text":"OK <p>The service is working as expected. Flags can be stored and retrieved. The functionality of the service is not impaired.</p> MUMBLE <p>The service is online but not working as expected. Some requests to the service were unsucessfull.</p> OFFLINE <p>The service is reported as offline. Flags couldn't be stored or received.</p> RECOVERING <p>The Service was OFFLINE or MUMBLE before. But is now working as expected. Because flags from the previous rounds could not be stored on your service it is marked as RECOVERING.</p> INTERNAL_ERROR <p>The Error is on the event organizers side. Please contact them. </p>"},{"location":"service/getting-started/","title":"Create a new Service","text":"<p>This section covers the necessary steps to create your own service and integrate it with the EnoEngine and bambictf framework. While you are pretty free in most design choices related to your service (as long as you get it working using a single docker-compose file), there are some things to consider especially with regards to the directory structure and the checker development to ensure everything works with the surrounding infrastructure.</p>"},{"location":"service/getting-started/#what-does-a-service-consist-of","title":"What does a service consist of?","text":"<p>A service consists of:</p> <ul> <li>the service</li> <li>the checker</li> <li>(internal) documentation</li> <li>GitHub Actions workflows to check that everyhing is working as expected</li> </ul>"},{"location":"service/getting-started/#service-structure","title":"Service Structure","text":"<p>All service repositories must follow a certain structure to ensure the automated deployment will work. There is an example repository to serve as reference here: https://github.com/enowars/enowars-service-example</p> <p>However, do note that this repository differs in some regards from an actual service repository, for example this repository contains multiple checker-directories to showcase the variety of existing checker libraries. So please do read the following notes carefully and ensure your service matches the structure described here.</p> <p>There are two directories called <code>service</code> and <code>checker</code> that are required and must be named and laid out exactly according to the specification.</p>"},{"location":"service/getting-started/#service","title":"Service","text":"<p>There must be a directory called <code>service</code> at the top level of your repository. The contents of this directory will be copied onto each vulnbox. Thus there MUST NOT be any internal documentation containing hints to vulnerabilities/exploits in this directory!</p> <p>When it comes to the contents of the directory, you are pretty free in how you layout your directory structure. However, the following conditions must be met:</p> <ol> <li>Your service MUST be able to be started simply by running <code>docker-compose up -d</code> in your <code>service</code>-directory. This is exactly what the provisioning process on the vulnbox does, thus it must not require any manual intervention to start the service.</li> <li>You MAY create an optional <code>setup.sh</code>-script in your <code>service</code>-directory that is executed BEFORE running <code>docker-compose up -d</code>, if you require any additional setup steps that can not reasonably be executed as part of your docker-compose setup.</li> <li>You MUST create a <code>.env</code>-in your <code>service</code> directory in which you set <code>COMPOSE_PROJECT_NAME=your_chosen_name_service</code>, e.g. <code>COMPOSE_PROJECT_NAME=n0t3b00k_service</code> if your service is called <code>n0t3b00k</code>. Otherwise docker compose might have issues when creating the networks, since it uses the directory name (in this case <code>service</code>) as prefix for the created networks, which might cause collisions with other services running on the same machine.</li> <li>You MUST coordinate your published ports with the other service authors to avoid port collisions when starting two services on one vulnbox.</li> </ol> <p>For a concise list of requirements or conventions that your service must or should follow, please review the tenets. For some more tips and explanations to help you with your service development, checkout the service development chapter.</p>"},{"location":"service/getting-started/#checker","title":"Checker","text":"<p>The checker stores the flags in your service, retrieves them and checks whether your service works as intended.</p> <p>There must be a directory called <code>checker</code> at the top level of your repository. The contents of this directory will be copied onto the checker VMs. The contents of this directory are not publicly accessible to the participants during the CTF.</p> <p>With regards to the directory structure, the following conditions must be met:</p> <ol> <li>Your checker MUST be able to be started simply by running <code>docker-compose up -d</code> in your <code>checker</code>-directory. This is exactly what the provisioning process on the checker VM does, thus it must not require any manual intervention to start the checker.</li> <li>You MUST create a <code>.env</code>-file in your <code>checker</code> directory in which you set <code>COMPOSE_PROJECT_NAME=your_chosen_name_checker</code>, e.g. <code>COMPOSE_PROJECT_NAME=n0t3b00k_checker</code> if your service is called <code>n0t3b00k</code>.</li> <li>You MUST coordinate your published port with the other service authors to avoid port collisions when starting two checkers on one checker VM. Note that while in the actual CTF the services and checkers will not be started on the same VM, you should avoid overlap between service ports and checker ports to allow starting the service and checker on the same VM in test setups (which is done e.g. during enochecker_test-Workflow)</li> </ol> <p>For more details on the checker development, please refer to the checker chapter of this documentation.</p>"},{"location":"service/getting-started/#github-actions-ci-workflows","title":"GitHub Actions CI-Workflows","text":"<p>We require all services to be tested automatically using enochecker_test. <code>enochecker_test</code> is a test framework which interfaces with your checker over the network in the same way as the EnoEngine does. It includes some basic test cases (e.g. simply storing a flag and retrieving the flag) and also some special testcases based on issues we encountered in the past with previous checkers. Note that enochecker_test succeeding DOES NOT guarantee that there are no issues with your service/checker! When in doubt, you should write additional tests (e.g. unit tests) specific to your service. More details on testing your checker can be found in the testing chapter.</p> <p>We provide an example workflow for testing your service with <code>enochecker_test</code> in the enowars-service-example repository. Please copy that to your own repository and adjust as necessary.</p> <p>Most importantly, you need to set the <code>ENOCHECKER_TEST_CHECKER_PORT</code> environment variable to match the published port of your checker.</p> <p>The steps of the workflow can be summarized as following: </p> <ul> <li>setup <code>enochecker_test</code></li> <li>build and start your service</li> <li>build and start your checker</li> <li>run <code>enochecker_test</code> against your checker/service</li> <li>clean up after the tests are completed (this is necessary since we are using self-hosted GitHub Actions runners and do not use a fresh VM for each run)</li> </ul>"},{"location":"service/getting-started/#documentation","title":"Documentation","text":"<p>You should include some (internal) documentation with your service. At least you should have a meaningful <code>README.md</code>. In addition, you are free to include any supporting documentation in the repository, for example in a separate <code>docs</code>-directory.</p>"},{"location":"service/getting-started/#create-a-service-repository","title":"Create a Service Repository","text":"<p>Create a private <code>enowars&lt;season&gt;-service-&lt;your-service-name&gt;</code> repository in the Enowars Organization. For example, for ENOWARS 5 and a service called <code>stldoctor</code> the repository would be called <code>enowars5-service-stldoctor</code>.</p> <p>Give the correct permissions to your team (Blue/Yellow) by going to <code>Settings -&gt; Access -&gt; Collaborators and teams</code> in your repository settings and giving <code>Read</code>-access to the team called e.g. <code>ENOWARS7-Blue</code> (if the current instance of ENOWARS is 7 and you are on the blue team).</p> <p>Structure the repository as described above.</p> <p>Begin developing your service and checker, making sure to commit, push and test often. You should try to get <code>enochecker_test</code> to pass as early as possible using a minimal implementation of your checker (e.g. a single putflag/getflag) and then, as you continue with the development of the service and add aditional checker functionality, ensure that the tests keep passing.</p>"},{"location":"service/service/","title":"Service Development","text":"<p>This page is still under construction.</p> <p>To get to know what the Service is doing visit the Getting Started Page.</p> <p>Your service must be startable via <pre><code>docker-compose up -f docker-compose.yml\n</code></pre></p> <p>Apart from that you are free to develop whatevery you like. \ud83d\ude0a</p>"},{"location":"service/tenets/","title":"Service &amp; Checker Tenets","text":"<p>In the following we are using RFC2119 Key word to specify the Service and Checker capabilities.</p> <p>Info</p> <p>\ud83d\udd34MUST   This word, or the terms \"REQUIRED\" or \"SHALL\", mean that the definition is an absolute requirement of the specification.</p> <p>\ud83d\udd34MUST NOT   This phrase, or the phrase \"SHALL NOT\", mean that the definition is an absolute prohibition of the specification.</p> <p>\ud83d\udfe1SHOULD   This word, or the adjective \"RECOMMENDED\", mean that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course.</p> <p>\ud83d\udfe1SHOULD NOT   This phrase, or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood and the case carefully weighed before implementing any behavior described with this label.</p> <p>\ud83d\udfe2MAY   This word, or the adjective \"OPTIONAL\", mean that an item is truly optional.  One vendor may choose to include the item because a particular marketplace requires it or because the vendor feels that it enhances the product while another vendor may omit the same item. An implementation which does not include a particular option MUST be prepared to interoperate with another implementation which does include the option, though perhaps with reduced functionality. In the same vein an implementation which does include a particular option MUST be prepared to interoperate with another implementation which does not include the option (except, of course, for the feature the option provides.)</p>"},{"location":"service/tenets/#service","title":"Service","text":"<p>A service:</p> <ul> <li>\ud83d\udd34 MUST be able to store and load flags for a specified number of rounds</li> <li>\ud83d\udd34 MUST NOT lose flags if it is restarted</li> <li>\ud83d\udd34 MUST be rebuilt as fast as possible, no redundant build stages should be executed every time the service is built</li> <li>\ud83d\udd34 MUST be able to endure the expected load</li> <li>\ud83d\udfe1 SHOULD NOT be a simple wrapper for a key-value database, and SHOULD expose more complex functionality</li> <li>\ud83d\udfe1 SHOULD NOT rewritable within within the timeframe of the contest</li> <li>\ud83d\udfe2 MAY be written in unexpected languages or using fun frameworks</li> </ul>"},{"location":"service/tenets/#vulnerabilities","title":"Vulnerabilities","text":"<p>A service: </p> <ul> <li>\ud83d\udd34 MUST have at least one complex vulnerability</li> <li>\ud83d\udd34 MUST have at least one \"location\" where flags are stored (called flag store)</li> <li>\ud83d\udfe1 SHOULD have more than one vulnerability</li> <li>\ud83d\udfe1 SHOULD NOT have unintended vulnerabilities</li> <li>\ud83d\udfe1 SHOULD NOT have vulnerabilities that allow the deletion but not the retrieval of flags</li> <li>\ud83d\udfe1 SHOULD NOT have vulnerabilities that allow only one attacker to extract a flag</li> <li>\ud83d\udfe2 MAY have additional flag stores, which requires a separate exploit to extract flags</li> </ul> <p>A vulnerability:</p> <ul> <li>\ud83d\udd34 MUST be exploitable and result in a correct flag</li> <li>\ud83d\udd34 MUST stay exploitable over the course of the complete game (I.e. auto delete old flags, if necessary) </li> <li>\ud83d\udd34 MUST be fixable with reasonable effort and without breaking the checker</li> <li>\ud83d\udd34 MUST be exploitable without renting excessive computing resources</li> <li>\ud83d\udd34 MUST be expoitable with reasonable amounts of network traffic</li> <li>\ud83d\udfe1 SHOULD NOT be easily replayable </li> </ul>"},{"location":"service/tenets/#checker","title":"Checker","text":"<p>A checker: </p> <ul> <li>\ud83d\udd34 MUST check whether a flag is retrievable, and MUST NOT fail if the flag is retrievable, and MUST fail if the flag is not retrievable</li> <li>\ud83d\udd34 MUST NOT rely on information stored in the service in rounds before the flag was inserted</li> <li>\ud83d\udd34 MUST NOT crash or return unexpected results under any circumstances</li> <li>\ud83d\udd34 MUST log sufficiently detailed information that operators can handle complaints from participants</li> <li>\ud83d\udd34 MUST check the entire functionality of the service and report faulty behavior, even unrelated to the vulnerabilities</li> <li>\ud83d\udfe1 SHOULD not be easily identified by the examination of network traffic</li> <li>\ud83d\udfe1 SHOULD use unusual, incorrect or pseudomalicious input to detect network filters</li> <li>\ud83d\udfe2 MAY use information stored in previous rounds, if it gracefully handles the unexpected absence of that information</li> </ul>"},{"location":"service/checker/checker-dotnet/","title":"Dotnet Checker","text":"<p>This page is still under construction.</p> <p>We provide a checker library for an easy start. </p>"},{"location":"service/checker/checker-golang/","title":"Golang Checker","text":"<p>This page is still under construction.</p> <p>We provide a checker library for an easy start. </p>"},{"location":"service/checker/checker-python/","title":"Python Checker","text":"<p>Contains outdated information</p> <p>This page is still under construction. It currently covers the old enochecker-library for Python, where as the current recommendation is the enochecker3-library</p> <p>We provide a checker library for an easy start. </p>"},{"location":"service/checker/checker-python/#development","title":"Development","text":"<p>For local development execute</p> <pre><code>cd checker/src\ngunicorn -c gunicorn.conf.py checker:app\n</code></pre> <p>You can add those settings to you <code>checker/src/gunicorn.conf.py</code> to make your development faster.</p> <pre><code>reload = True\nloglevel = 'debug'\n</code></pre>"},{"location":"service/checker/checker-python/#writing","title":"Writing","text":"<p>For a simple checker, subclass <code>BaseChecker</code> (API Documentation).</p> <pre><code>from enochecker import BaseChecker, BrokenServiceException, run\n\nclass AwesomeChecker(BaseChecker):\n    flag_count = 2\n    noise_count = 1\n    havoc_count = 1\n\n\n    def putflag(self):  # type: () -&gt; None\n        # TODO: Put flag to service\n        self.debug(\"flag is {}\".format(self.flag))\n        self.http_post(\"/putflaghere\", params={\"flag\": self.flag})\n        # ...\n\n    def getflag(self):  # type: () -&gt; None\n        # tTODO: Get the flag.\n        if not self.http_get(\"/getflag\") == self.flag:\n            raise BrokenServiceException(\"Ooops, wrong Flag\")\n\n    def putnoise(self):\n        # put some noise\n        with self.connect() as telnet:\n            telnet.write(self.noise)\n\n    def getnoise(self):\n        with self.connect() as telnet:\n            telnet.write(\"gimmeflag\\n\")\n            telnet.read_expect(self.noise)\n\n    def havoc(self):\n        self.http(\"FUNFUN\").text == \"FUNFUN\"\n\n\nif __name__ == \"__main__\":\n    run(AwesomeChecker)\n</code></pre> <p>To get to know more about what each function should do read the Getting Started Guide.</p> <p>The current flag is made available through the <code>self.flag</code> instance variable. If you wish to place more than one flag per round in different places, the content of <code>self.flag_idx</code> tells you which flag you should deploy, starting with <code>0</code>.</p> <p>In that case you should match the value of the variable in the <code>putflag()</code> and <code>getflag()</code> functions and act accordingly. You can communicate the number of flags you want to store per round to the game engine by setting the class variable <code>flag_count</code>.</p> <p>The noise, which is stored/retrieved using the <code>putnoise()</code> and <code>getnoise()</code> functions, is similar to the flag. Your checker should store/retrieve noise to check that the services is still working as intended. Unlike the flag, the noise does not need to remain secret, so you could for example post it on a publicly accessible comment section (provided your service has such functionality) to ensure this still works as intended. You can communicate the number of noises you want to store per round to the game engine by setting the class variable <code>noise_count</code>.</p> <p>The <code>havoc()</code> function is intended to check the functionality of those parts of the service which is not covered by the flag and noise functionality. You can communicate the number of havoc calls you want to receive per round to the game engine by setting the class variable <code>havoc_count</code>.</p>"},{"location":"service/checker/checker-python/#communicating-the-service-status","title":"Communicating the service status","text":"<p>To tell the game engine about the status of the service under check, you can raise various exceptions during the execution of your functions. If the execution of the function finishes without any exception, it is assumed the status of the service is ok.</p> <p>In case the service appears to be offline, for example because your connection times out, you should raise a <code>OfflineException</code>.</p> <p>In case the service is online but is not working as intended, for example because it responds with unexpected contents or the flag is missing, you should raise a <code>BrokenServiceException</code>.</p> <p>If the function raises any other exceptions, this results in the <code>CHECKER BROKEN</code> status on the scoreboard. This should usually never happen, so make sure to catch all exceptions the functions you use might raise.</p>"},{"location":"service/checker/checker-python/#persisting-data-across-executions","title":"Persisting data across executions","text":"<p>Usually you need to store some information when storing the flag that is needed later. This could be something like usernames and passwords which are necessary to access the flag. There are multiple storage backends (at the moment <code>~enochecker.storeddict.StoredDict</code> and <code>~enochecker.nosqldict.NoSqlDict</code>) that are accessible through a common interface.</p> <p>The <code>self.team_db</code> dictionary is persisted across restarts. A good key for storing your information is usually the flag itself, since you want to access the information you stored during the <code>putflag</code> call during a later <code>getflag</code> call with the same flag in <code>self.flag</code>. An example for using the <code>self.team_db</code>:</p> <pre><code>import secrets\n\n[...]\n\nclass AwesomeChecker(BaseChecker):\n    def putflag(self):\n        username = secrets.token_hex(8)\n        password = secrets.token_hex(8)\n        self.team_db[self.flag] = {\n            \"username\": username,\n            \"password\": password,\n        }\n        [... register with the generated credentials and store the flag ...]\n\n    def getflag(self):\n        if self.flag not in self.team_db or \"username\" not in self.team_db[self.flag] or \"password\" not in self.team_db[self.flag]:\n            raise BrokenServiceException(\"storing the corresponding flag was unsuccessful\")\n        username = self.team_db[self.flag][\"username\"]\n        password = self.team_db[self.flag][\"password\"]\n        [... register with the retrieved credentials and get the flag ...]\n</code></pre>"},{"location":"service/checker/checker-python/#testing","title":"Testing","text":"<p>Test your checker by executing:</p> Bash <pre><code>pip install enochecker-test\nENOCHECKER_TEST_CHECKER_ADDRESS=\"localhost\"\nENOCHECKER_TEST_CHECKER_PORT=\"3031\"\nENOCHECKER_TEST_SERVICE_ADDRESS=\"localhost\"\nenochecker_test\n</code></pre> Powershell <pre><code>pip install enochecker-test\n$env:ENOCHECKER_TEST_CHECKER_ADDRESS=\"localhost\"\n$env:ENOCHECKER_TEST_CHECKER_PORT=\"3031\"\n$env:ENOCHECKER_TEST_SERVICE_ADDRESS=\"localhost\"\nenochecker_test\n</code></pre>"},{"location":"service/checker/checker-rust/","title":"Rust Checker","text":"<p>This page is still under construction.</p> <p>We provide a checker library for an easy start. </p>"},{"location":"service/checker/checker/","title":"Checker Development","text":"<p>To learn how the checker fits into the overall repository structure, please review the Getting Started Page. For more information on testing your checker and integrating it as part of the CI process, please review the Testing Page. You can find information on the available libraries for implementing your checker at the end of the page.</p>"},{"location":"service/checker/checker/#general-architecture-and-core-concepts","title":"General Architecture and Core Concepts","text":"<p>While not directly relevant for the development of your service and corresponding checker, there are some parts of the general architecture of the CTF infrastructure  and core concepts that are useful to understand.</p> <p>If you are interested in the low-level workings of the checker protocol, you should check out the checker protocol specification.</p> <p>The <code>EnoEngine</code> is responsible for \"deciding\" which tasks to run and when to run them. This is done through the configuration of the engine itself. When the engine wants to launch a task, the <code>EnoLauncher</code> issues an HTTP request adhering to the checker protocol specification to the checker. This means that each checker is an HTTP service by itself.</p> <p>When using one of the libraries, the library handles most or all of the functionality related to receiving and handling the HTTP requests. As a service author, you only implement the checker methods and how they are called is transparent to you. You can assume that all validation of the request itself as well as authentication/authorization (should that ever be considered necessary) is handled by the library and does not need to be implemented as part of the checker methods.</p> <p>However, while you can assume that the engine will only send reasonable requests, there are some cases where you might end up with an inconsistent state that you should handle in your implementation of the checker methods.</p> <p>For example, the engine will send getflag-tasks even when the corresponding putflag-task is considered to have failed. The reasoning for this is that the flag might have been stored successfully and all relevant data for retrieving it was stored in the database, but only at a later point in the task did an error occur or the task timeouted after storing the flag and data in the database but before being able to return the success status. It would be unfair to consider all subsequent getflag-tasks to have failed. While it could be argued that from the perspective of the engine the putflag never succeeded and thus the flag can not be present in the service, it might in fact be there and the teams should get the chance to gain those SLA points by executing the getflag-task.</p> <p>Since there is no way to distinguish between those cases from the perspective from the engine, the engine will also send getflag-tasks for putflag-tasks that have failed from the perspective of your checker (e.g. because the registration was unsuccessful) and thus the credentials are missing from the database. In those cases, your checker MUST NOT return an internal error and instead handle those cases gracefully, e.g. by returning MUMBLE with a response message indicating that the earlier user registration failed and thus the flag can not be retrieved.</p>"},{"location":"service/checker/checker/#task-chain","title":"Task Chain","text":"<p>One important concept that you should fully understand is that of a \"task chain\" as well as which arguments of a <code>CheckerTaskMessage</code> can be considered unique identifiers for which purposes. A task chain is a series checker tasks that consist of one putflag-task with the corresponding getflag-tasks for the same flag, one putnoise-task with the corresponding getnoise-tasks for the same noise, a single havoc-task or or a single exploit-task.</p> <p>In general, it can be said that you will probably want to use the <code>taskChainId</code> as unique identifier for storing e.g. usernames and passwords unless you have a very good reason to use something else. When your flag is stored in some location where it is visible to the logged in user, you probably register a new user in your putflag-task. When retrieving the flag in your getflag-task, you need to login as that user and check whether the flag is still present. In both of those tasks, the <code>taskChainId</code> will be identical, thus it makes sense to use the <code>taskChainId</code> as the identifier in your database for storing those credentials.</p> <p>Some checker libraries, e.g. <code>enochecker3</code> for Python, provide abstraction layers around this mechanism in the form of e.g. a <code>ChainDB</code> object, which internally stores the data using the <code>taskChainId</code> as identifier and externally can be used like a normal key-value-store where all data stored/retrieved is always limited to the data related to the task chain of the current checker task being executed.</p> <p>Other arguments in the <code>CheckerTaskMessage</code> like the <code>taskId</code>, <code>teamId</code>, <code>currentRoundId</code>, <code>relatedRoundId</code> and <code>variantId</code> are available to you and are used internally by the checker libraries for e.g. logging, but it is rare that you as the service developer have a good reason to actually use those values in the implementation of your checker tasks. Most importantly, unless you know what you are doing and have a good reason to do so, you do not want to use any of those values as identifiers for storing data in the checker's database.</p> <p>One valid use case for using e.g. the <code>teamId</code> as a database id could be reusing accounts across multiple task chains to obfuscate the behavior of the checker a bit and ensure that not all requests sent by the checker look identical (e.g. all putflags start with the registration of a new user). However, such use cases require a lot of attention with error handling, for example, since a putflag-task should be independent from other tasks in the sense that an unrelated task failing must not lead to the putflag failing just because a user-account from the previous task is missing.</p>"},{"location":"service/checker/checker/#checker-methods","title":"Checker Methods","text":"<p>There are six methods defined in the checker protocol. Five of them, namely <code>putflag</code>, <code>getflag</code>, <code>putnoise</code>, <code>getnoise</code> and <code>havoc</code>, are used during the CTF and have a direct influence on the score, where as the <code>exploit</code> method is used only for (automated) testing and not used during the CTF.</p> <p>For each of the different methods, there may be multiple variants. That means your checker might implement two different variants of <code>putflag</code> or <code>getflag</code> that store flags in different parts of the service. Ideally this should require the exploitation of different vulnerabilities, such that there are basically two different services within your service. In that case we speak of different \"flag stores\", which are also displayed on the scoreboard and are considered separately when identifying first bloods, meaning there is one first blood pre flag store and not just per service.</p> <p>When looking at <code>putnoise</code>, <code>getnoise</code> and <code>havoc</code>, multiple variants simply allow you to test additional functionality of your service. All tasks for <code>putnoise</code>, <code>getnoise</code> and <code>havoc</code> must succeed for the service of a team to be considered \"up\" and the team receiving SLA points. </p>"},{"location":"service/checker/checker/#putflaggetflag","title":"Putflag/Getflag","text":"<p>The <code>putflag</code> and <code>getflag</code> methods can be considered the core functionality of the checker. The <code>putflag</code> method is used to store a flag in the service, where as <code>getflag</code> is used to check if the flag is still present. Your checker must be able to handle multiple subsequent <code>getflag</code>-tasks for a single flag.</p> <p>Since the flag must be placed somewhere in the service where it is not publicly accessible, you usually have some form of credentials (e.g. username and password) generated in your <code>putflag</code>-task that you need to store. Usually you would want to use the <code>taskChainId</code> as identifier in your database for storing and retrieving those credentials.</p> <p>When implementing multiple variants for <code>putflag</code> and <code>getflag</code>, you must ensure that both methods have an equal number of variants. The corresponding <code>putflag</code> and <code>getflag</code> variants for the same flag store must have the same variant ids, i.e., the engine will call <code>getflag</code> with <code>variantId</code> 0 to check whether the flag deposited by the <code>putflag</code> task with <code>variantId</code> 0 ist still present.</p> <p>Depending on the design of your service, it might be useful to have some publicly available information giving the players a hint where the current flag can be found. For example, this could be the username of the account which was used to store the flag and should thus be considered the target of the exploits. Such information can be returned as <code>attackInfo</code> in your <code>putflag</code>-method. This <code>attackInfo</code> is always a string, so if you only provide the username you can simply return that, if you want to return more complex JSON objects you need to stringify them before returning them. How you lay out the <code>attackInfo</code> (and if you provide <code>attackInfo</code> at all) is up to you as the service author to decide. In general, if, without <code>attackInfo</code>, the attackers would need to enumerate a large number of entries, causing high load to the service, it is a good idea to include <code>attackInfo</code>.</p> <p>It can be assumed that, when enumerating all accounts/entries is theoretically possible, simply providing <code>attackInfo</code> reduces the load and makes the life easier for the attackers, the defenders and you as the organizer who needs to provide the network infrastructure. If finding the correct target to attack is part of your vulnerability/exploit somehow and providing <code>attackInfo</code> would take that away, you would probably not want to provide any information.</p>"},{"location":"service/checker/checker/#putnoisegetnoise","title":"Putnoise/Getnoise","text":"<p>The <code>putnoise</code> and <code>getnoise</code> methods are quite similar to <code>putflag</code> and <code>getflag</code>, so most things mentioned in the previous chapter apply here as well.</p> <p>The key difference is that noise, unlike the flag, is not considered secret and thus might be stored in publicly available places. It just needs to be stored somewhere, where it can be retrieved later on. Unlike with flags, you can also use two different variants to store noise in the same location and place/retrieve it there using different methods (of course, whether this is possible or not depends on your service).</p> <p>Since the noise is not intended to be exploited, the <code>putnoise</code> task does not have anything equivalent to <code>attackInfo</code>.</p>"},{"location":"service/checker/checker/#havoc","title":"Havoc","text":"<p>The <code>havoc</code> method can be used to test any functionality that is not covered by <code>putflag</code>/<code>getflag</code> or <code>putnoise</code>/<code>getnoise</code>. Unlike the other methods which are pairs of <code>put</code> and <code>get</code> and thus need to store information somewhere, each <code>havoc</code> is completely independent and thus you do not need to store any information in the service or checker.</p> <p>You are of course free to reuse e.g. accounts from earlier <code>havoc</code>-tasks whose credentials you store in the checker database, however, the absence of such accounts MUST NOT lead to the <code>havoc</code> failing.</p>"},{"location":"service/checker/checker/#exploit","title":"Exploit","text":"<p>The <code>exploit</code> method is only used for testing purposes and will not be used during the CTF. By implementing this method, you are able to \"prove\" that your service can actually be exploited. This is especially useful as part of the CI process, to avoid accidentally \"breaking\" a vulnerability leading to an unexploitable service.</p> <p>You can also implement multiple variants of the exploit method and also multiple variants for a single flag store. In some cases there are multiple vulnerabilities that allow retrieving a flag from the same flag store, in which case you should implement one exploit variant per vulnerability/exploit chain.</p> <p>To actually \"prove\" that the exploit method is working, it needs to return a flag as the result of the task. Since there might be multiple flags that are exploitable with a single exploit, the caller provides a <code>flagHash</code> which is the hex-encoded SHA256-hash of the flag the caller wishes to retrieve. It is the caller's responsibility to place the flag there and provide the <code>attackInfo</code> if available.</p> <p>When using <code>enochecker_test</code> for testing, <code>enochecker_test</code> first issues a <code>putflag</code> task with a newly generated flag. It then passes the <code>attackInfo</code> returned by the <code>putflag</code> and the hash of the flag as <code>flagHash</code> to the <code>exploit</code>-task. Most libraries include some convenience mechanism for dealing with the <code>flagHash</code>, e.g. the <code>FlagSearcher</code> in <code>enochecker3</code>, which takes <code>str</code> or <code>bytes</code> as input and checks whether any of the plain text flags included in that input match the hash.</p> <p>To allow the <code>exploit</code>-method to identify the flags matching the flag format in the data returned by the service, there is the argument <code>flagRegex</code>, which is a regular expression describing the format of the flag. This <code>flagRegex</code> is e.g. used internally by the <code>FlagSearcher</code> to identify the flags in the input passed to it.</p> <p>For more details on how the <code>exploit</code>-method is used by the automated testing procedure with <code>enochecker_test</code>, please review the testing chapter.</p> <p>Please note that some tools, most notably <code>enochecker_cli</code>, provide convenience mechanisms for working with the <code>flagHash</code>. <code>enochecker_cli</code> expects the plain flag (passed in using <code>--flag</code>) as input and calculates the hash of the flag internally before issuing the request to the checker. This makes issuing subsequent <code>putflag</code>- and <code>exploit</code>-tasks during testing much easier, since you can simply leave the <code>--flag</code> from your <code>putflag</code>-call as is when changing the method to <code>exploit</code>.</p>"},{"location":"service/checker/checker/#libraries","title":"Libraries","text":"<p>You can write the checker in any language you like, but we provide some guidance for the following: </p> <ul> <li>Python</li> </ul> <p>There are also libraries for the following languages, but they are not covered extensively on this page, so they might be harder to get into. Also, the python library can be considered the reference implementation of the checker specification and thus will always match the current version of the API specification, which is not guaranteed for the below checker libraries.</p> <ul> <li>Dotnet</li> <li>Golang</li> <li>Rust</li> </ul> <p>You could write your checker in other languages by creating your own implementation of the checker protocol specification, but then you are responsible for ensuring the stability of the checker library in addition to your actual service and checker implementation.</p>"},{"location":"service/checker/testing/","title":"Testing the Checker","text":"<p>This page is still under construction.</p> <p>We have a testing Library for testing any checker implementation: https://github.com/enowars/enochecker_test</p> <p>You can add it to your repository with this <code>.github/workflows/enochecker_test.yml</code></p> <p>You can manually check whether your checker is working with the CLI.</p>"}]}